### Выводы

Прогон сценариев(вставки и удаления, вставки и поиска) показал, что, при отстутствии deadlock-ов у версии с тонкой синхронизацией, версия с грубой в среднем более производительна. Моя теория заключается в том, что использование мьютексов в данной задаче было ошибкой, поскольку доступ к этому примитиву, как к оболочке над объектом ОС, может замедлять операции прохода по дереву. (Как адекватно заменить в текущем алгоритме мьютексы на, например, мониторы или спин локи, чтобы подтвердить теорию, я еще не придумал; однако пробное использование вместо мьютекса (бинарного)SemaphoreSlim показывало некоторое улучшение в производительности fine-grained версии на прогонах тех же сценариев).

### Тесты

Корректная работа при параллельном исполнении тестируется с помощью стресс-тестов, покрывающих сценарии "вставка элементов тасками - удаление тех же элементов тасками - проверка дерева на пустоту" и аналогичный сценарий для вставки и поиска(с проверкой того, что все найдено).
